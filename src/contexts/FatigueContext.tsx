/**
 * 피로도 데이터 관리를 위한 Context
 * V2: HealthService, SedentaryDetector, SleepEstimator 통합
 * V3: 폰 유휴 자동 회복 + 알림 "했어요!" 액션
 */

import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useRef,
  useCallback,
  ReactNode,
} from 'react';
import {Platform, AppState, AppStateStatus} from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import {
  ActivityRecord,
  ActivityType,
  DailyFatigueData,
  HealthDataSnapshot,
  SedentaryEvent,
  InputMode,
  DataSource,
} from '../types';
import {
  calculateFatigue,
  calculateFatigueV2,
  calculateFatigueStats,
} from '../utils/fatigueCalculator';
import {useSettings} from './SettingsContext';
import {createHealthService, IHealthService} from '../services/HealthService';
import {SedentaryDetector} from '../services/SedentaryDetector';
import {SleepEstimator} from '../services/SleepEstimator';
import {HistoryService} from '../services/HistoryService';
import {NotificationService} from '../services/NotificationService';
import {WidgetService} from '../services/WidgetService';
import {DailyHistoryRecord} from '../types';
import {getFatigueLevelFromPercentage, FATIGUE_LEVEL_INFO} from '../utils/constants';

interface FatigueContextType {
  dailyData: DailyFatigueData;
  fatiguePercentage: number;
  fatigueMessage: string;
  recommendation: string;
  isLoading: boolean;
  inputMode: InputMode;
  healthData: HealthDataSnapshot | null;
  sedentaryEvents: SedentaryEvent[];
  dataSourceLabel: string;
  addActivity: (
    activityType: ActivityType,
    durationMinutes: number,
    note?: string,
  ) => void;
  removeActivity: (activityId: string) => void;
  clearAllActivities: () => void;
  getTotalMinutesForActivity: (activityType: ActivityType) => number;
  setManualSliderValue: (value: number) => void;
  refreshHealthData: () => Promise<void>;
  getWeeklyHistory: () => Promise<(DailyHistoryRecord | null)[]>;
}

const FatigueContext = createContext<FatigueContextType | undefined>(undefined);

const STORAGE_KEY = '@pirodo_daily_data';
const HEALTH_REFRESH_INTERVAL = 5 * 60 * 1000; // 5분

// 폰 유휴 자동 회복 설정
const IDLE_REST_THRESHOLD = 15 * 60 * 1000; // 15분 이상 백그라운드 → 휴식 인정
const IDLE_REST_MAX = 60; // 최대 60분까지 인정
const IDLE_REST_RATE = 0.5; // 유휴 1분 = 휴식 0.5분으로 환산

const DATA_SOURCE_LABELS: Record<InputMode, string> = {
  [InputMode.WATCH]: 'Watch',
  [InputMode.PHONE]: 'Phone',
  [InputMode.MANUAL]: 'Manual',
};

export const FatigueProvider: React.FC<{children: ReactNode}> = ({children}) => {
  const {settings} = useSettings();

  const [dailyData, setDailyData] = useState<DailyFatigueData>({
    date: new Date().toISOString().split('T')[0],
    activities: [],
    currentFatiguePercentage: 50,
  });

  const [fatiguePercentage, setFatiguePercentage] = useState(50);
  const [fatigueMessage, setFatigueMessage] = useState('');
  const [recommendation, setRecommendation] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [healthData, setHealthData] = useState<HealthDataSnapshot | null>(null);
  const [sedentaryEvents, setSedentaryEvents] = useState<SedentaryEvent[]>([]);

  const healthServiceRef = useRef<IHealthService | null>(null);
  const sedentaryDetectorRef = useRef<SedentaryDetector | null>(null);
  const sleepEstimatorRef = useRef<SleepEstimator | null>(null);
  const backgroundTimeRef = useRef<number | null>(null);

  // 데이터 로드
  useEffect(() => {
    loadData();
  }, []);

  // 알림 "했어요!" 콜백 등록
  useEffect(() => {
    NotificationService.registerActionCallback((rewardAmount: number) => {
      const restActivity: ActivityRecord = {
        id: `action_${Date.now()}`,
        type: ActivityType.REST,
        durationMinutes: rewardAmount,
        timestamp: new Date(),
        note: '알림 액션 완료',
        source: DataSource.NOTIFICATION_ACTION,
        autoGenerated: true,
      };

      setDailyData(prev => ({
        ...prev,
        activities: [...prev.activities, restActivity],
      }));
    });
  }, []);

  // 폰 유휴 감지 (백그라운드 → 포그라운드 복귀 시)
  useEffect(() => {
    const handleAppStateChange = (nextState: AppStateStatus) => {
      if (nextState === 'background' || nextState === 'inactive') {
        // 백그라운드 진입 시간 기록
        backgroundTimeRef.current = Date.now();
      } else if (nextState === 'active' && backgroundTimeRef.current) {
        // 포그라운드 복귀: 유휴 시간 계산
        const idleMs = Date.now() - backgroundTimeRef.current;
        backgroundTimeRef.current = null;

        if (idleMs >= IDLE_REST_THRESHOLD) {
          const idleMinutes = Math.floor(idleMs / 60000);
          const restMinutes = Math.min(
            Math.round(idleMinutes * IDLE_REST_RATE),
            IDLE_REST_MAX,
          );

          if (restMinutes > 0) {
            const autoRest: ActivityRecord = {
              id: `idle_${Date.now()}`,
              type: ActivityType.REST,
              durationMinutes: restMinutes,
              timestamp: new Date(),
              note: `폰 미사용 ${idleMinutes}분 → 자동 회복`,
              source: DataSource.AUTO_IDLE_REST,
              autoGenerated: true,
            };

            setDailyData(prev => ({
              ...prev,
              activities: [...prev.activities, autoRest],
            }));
          }
        }
      }
    };

    const subscription = AppState.addEventListener('change', handleAppStateChange);
    return () => subscription.remove();
  }, []);

  // 날짜 변경 체크 (자정에 데이터 초기화)
  useEffect(() => {
    const checkDate = setInterval(() => {
      const today = new Date().toISOString().split('T')[0];
      if (dailyData.date !== today) {
        resetDailyData();
      }
    }, 60000);

    return () => clearInterval(checkDate);
  }, [dailyData.date]);

  // 데이터 변경 시 피로도 재계산
  useEffect(() => {
    if (!isLoading) {
      updateFatigue();
      saveData();
    }
  }, [dailyData.activities, dailyData.manualSliderValue, healthData, sedentaryEvents]);

  // HealthService 초기화 (inputMode 변경 시)
  useEffect(() => {
    healthServiceRef.current?.disconnect();
    healthServiceRef.current = createHealthService(settings.inputMode);

    if (settings.inputMode !== InputMode.MANUAL) {
      healthServiceRef.current.requestPermissions().then(granted => {
        if (granted) {
          refreshHealthData();
        }
      });
    }

    return () => {
      healthServiceRef.current?.disconnect();
    };
  }, [settings.inputMode]);

  // SedentaryDetector 초기화
  useEffect(() => {
    sedentaryDetectorRef.current?.stop();

    if (
      settings.enableSedentaryDetection &&
      settings.inputMode !== InputMode.MANUAL
    ) {
      sedentaryDetectorRef.current = new SedentaryDetector(
        settings,
        (event: SedentaryEvent) => {
          // 앉아있기 이벤트를 기록
          setSedentaryEvents(prev => [...prev, event]);

          // 자동 SITTING 활동 추가
          const autoActivity: ActivityRecord = {
            id: `auto_${Date.now()}`,
            type: ActivityType.SITTING,
            durationMinutes: event.durationMinutes,
            timestamp: event.endTime,
            note: '자동 감지',
            source: DataSource.AUTO_SEDENTARY,
            autoGenerated: true,
          };

          setDailyData(prev => ({
            ...prev,
            activities: [...prev.activities, autoActivity],
          }));
        },
      );
      sedentaryDetectorRef.current.start();
    }

    return () => {
      sedentaryDetectorRef.current?.stop();
    };
  }, [settings.enableSedentaryDetection, settings.inputMode]);

  // SleepEstimator 초기화 (Phone 모드)
  useEffect(() => {
    sleepEstimatorRef.current?.stop();

    if (settings.inputMode === InputMode.PHONE) {
      sleepEstimatorRef.current = new SleepEstimator();
      sleepEstimatorRef.current.start();
    }

    return () => {
      sleepEstimatorRef.current?.stop();
    };
  }, [settings.inputMode]);

  // 주기적 건강 데이터 갱신
  useEffect(() => {
    if (settings.inputMode === InputMode.MANUAL) return;

    const interval = setInterval(() => {
      refreshHealthData();
    }, HEALTH_REFRESH_INTERVAL);

    return () => clearInterval(interval);
  }, [settings.inputMode]);

  const refreshHealthData = useCallback(async () => {
    const service = healthServiceRef.current;
    if (!service) return;

    try {
      const now = new Date();
      const startOfDay = new Date(now);
      startOfDay.setHours(0, 0, 0, 0);

      const [stepCount, heartRate, hrv, sleepData, stressLevel] =
        await Promise.all([
          service.getStepCount(startOfDay, now),
          service.getHeartRate(startOfDay, now),
          service.getHeartRateVariability(startOfDay, now),
          service.getSleepData(now),
          service.getStressLevel(),
        ]);

      // 폰 수면 추정
      let estimatedSleepData = null;
      if (settings.inputMode === InputMode.PHONE && sleepEstimatorRef.current) {
        estimatedSleepData = sleepEstimatorRef.current.estimateSleep();
      }

      const snapshot: HealthDataSnapshot = {
        timestamp: now,
        source:
          Platform.OS === 'ios'
            ? DataSource.APPLE_HEALTH
            : DataSource.GOOGLE_FIT,
        stepCount: stepCount || undefined,
        heartRate: heartRate || undefined,
        heartRateVariability: hrv || undefined,
        sleepData: sleepData || undefined,
        stressLevel: stressLevel || undefined,
        estimatedSleepData: estimatedSleepData || undefined,
      };

      setHealthData(snapshot);
    } catch (e) {
      console.error('건강 데이터 갱신 실패:', e);
    }
  }, [settings.inputMode]);

  const loadData = async () => {
    try {
      const stored = await AsyncStorage.getItem(STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        const today = new Date().toISOString().split('T')[0];

        if (
          !parsed ||
          typeof parsed !== 'object' ||
          !parsed.date ||
          !Array.isArray(parsed.activities)
        ) {
          resetDailyData();
          return;
        }

        if (parsed.date === today) {
          const activities = parsed.activities
            .filter((a: any) => {
              return (
                a &&
                typeof a === 'object' &&
                a.id &&
                a.type &&
                typeof a.durationMinutes === 'number' &&
                a.durationMinutes >= 0 &&
                a.timestamp
              );
            })
            .map((a: any) => ({
              ...a,
              timestamp: new Date(a.timestamp),
            }));
          setDailyData({...parsed, activities});

          // 저장된 앉아있기 이벤트 복원
          if (parsed.sedentaryEvents) {
            setSedentaryEvents(
              parsed.sedentaryEvents.map((e: any) => ({
                ...e,
                startTime: new Date(e.startTime),
                endTime: new Date(e.endTime),
              })),
            );
          }
        } else {
          resetDailyData();
        }
      }
    } catch (error) {
      console.error('Failed to load data:', error);
      resetDailyData();
    } finally {
      setIsLoading(false);
    }
  };

  const saveData = async () => {
    try {
      const dataToSave = {
        ...dailyData,
        sedentaryEvents,
        inputMode: settings.inputMode,
      };
      await AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
    } catch (error) {
      console.error('Failed to save data:', error);
    }
  };

  const saveToHistory = async (data: DailyFatigueData) => {
    const sleepActivities = data.activities.filter(
      a => a.type === ActivityType.SLEEP,
    );
    const sleepMinutes = sleepActivities.reduce(
      (sum, a) => sum + a.durationMinutes,
      0,
    );

    const record: DailyHistoryRecord = {
      date: data.date,
      fatiguePercentage: data.currentFatiguePercentage,
      stepCount: healthData?.stepCount ?? 0,
      sleepHours: Math.round((sleepMinutes / 60) * 10) / 10,
      activityCount: data.activities.length,
    };
    await HistoryService.saveDailyRecord(record);
  };

  const resetDailyData = async () => {
    // 이전 날 데이터를 히스토리에 저장
    if (dailyData.activities.length > 0 || dailyData.manualSliderValue != null) {
      await saveToHistory(dailyData);
    }

    const newData: DailyFatigueData = {
      date: new Date().toISOString().split('T')[0],
      activities: [],
      currentFatiguePercentage: 50,
    };
    setDailyData(newData);
    setSedentaryEvents([]);
    setHealthData(null);
  };

  const updateFatigue = () => {
    const calculated = calculateFatigueV2(
      dailyData.activities,
      healthData,
      sedentaryEvents,
      dailyData.manualSliderValue ?? null,
      settings.inputMode,
      50,
    );
    const stats = calculateFatigueStats(dailyData.activities, calculated);

    setFatiguePercentage(calculated);
    setFatigueMessage(stats.fatigueMessage);
    setRecommendation(stats.recommendation);

    // 알림 체크
    if (settings.enableNotifications) {
      NotificationService.checkFatigueAlert(calculated);

      // 앉아있기 알림
      const totalSedentaryMin = sedentaryEvents.reduce(
        (sum, e) => sum + e.durationMinutes,
        0,
      );
      NotificationService.checkSedentaryAlert(totalSedentaryMin);

      // 수면 부족 알림
      const sleepInfo = healthData?.sleepData ?? healthData?.estimatedSleepData;
      if (sleepInfo) {
        NotificationService.checkSleepAlert(sleepInfo.totalMinutes / 60);
      }
    }

    // 위젯 데이터 업데이트
    const level = getFatigueLevelFromPercentage(calculated);
    const levelInfo = FATIGUE_LEVEL_INFO[level];
    const sleepInfo = healthData?.sleepData ?? healthData?.estimatedSleepData;
    WidgetService.updateWidgetData({
      fatiguePercentage: calculated,
      fatigueLevel: levelInfo.displayName,
      fatigueColor: levelInfo.color,
      fatigueMessage: stats.fatigueMessage,
      lastUpdated: new Date().toISOString(),
      stepCount: healthData?.stepCount ?? 0,
      sleepHours: sleepInfo ? Math.round((sleepInfo.totalMinutes / 60) * 10) / 10 : 0,
    });

    setDailyData(prev => {
      const updated = {
        ...prev,
        currentFatiguePercentage: calculated,
      };
      // 오늘 데이터를 히스토리에 업데이트
      saveToHistory(updated);
      return updated;
    });
  };

  const addActivity = (
    activityType: ActivityType,
    durationMinutes: number,
    note?: string,
  ) => {
    const newActivity: ActivityRecord = {
      id: Date.now().toString(),
      type: activityType,
      durationMinutes,
      timestamp: new Date(),
      note,
      source: DataSource.MANUAL_ACTIVITY,
      autoGenerated: false,
    };

    setDailyData(prev => ({
      ...prev,
      activities: [...prev.activities, newActivity],
    }));
  };

  const removeActivity = (activityId: string) => {
    setDailyData(prev => ({
      ...prev,
      activities: prev.activities.filter(a => a.id !== activityId),
    }));
  };

  const clearAllActivities = () => {
    setDailyData(prev => ({
      ...prev,
      activities: [],
      manualSliderValue: undefined,
    }));
    setSedentaryEvents([]);
  };

  const getTotalMinutesForActivity = (activityType: ActivityType): number => {
    return dailyData.activities
      .filter(a => a.type === activityType)
      .reduce((sum, a) => sum + a.durationMinutes, 0);
  };

  const setManualSliderValue = (value: number) => {
    setDailyData(prev => ({
      ...prev,
      manualSliderValue: Math.round(value),
    }));
  };

  return (
    <FatigueContext.Provider
      value={{
        dailyData,
        fatiguePercentage,
        fatigueMessage,
        recommendation,
        isLoading,
        inputMode: settings.inputMode,
        healthData,
        sedentaryEvents,
        dataSourceLabel: DATA_SOURCE_LABELS[settings.inputMode],
        addActivity,
        removeActivity,
        clearAllActivities,
        getTotalMinutesForActivity,
        setManualSliderValue,
        refreshHealthData,
        getWeeklyHistory: () => HistoryService.getWeeklyHistory(),
      }}>
      {children}
    </FatigueContext.Provider>
  );
};

export const useFatigue = (): FatigueContextType => {
  const context = useContext(FatigueContext);
  if (!context) {
    throw new Error('useFatigue must be used within FatigueProvider');
  }
  return context;
};
